<!DOCTYPE html>
<html>
<head>
    <title>Procedural Platformer</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            text-align: center;
        }
        canvas {
            border: 2px solid #fff;
            background-color: #34495e;
        }
        #score {
            color: white;
            font-size: 24px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Score: 0</div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // Game constants
        const STANDARD_PLATFORM_WIDTH = 100;
        const FIRST_PLATFORM_WIDTH = 300;
        const PLATFORM_HEIGHT = 20;
        const PLAYER_SIZE = 20;
        const JUMP_FORCE = -10;  // Reduced jump force
        const DOUBLE_JUMP_FORCE = -8; // Slightly weaker double jump
        const GRAVITY = 1.0;
        const GAME_SPEED = 5;
        const DOUBLE_JUMP_COST = 50;

        // Platform colors sequence
        const PLATFORM_COLORS = [
            '#e74c3c', // Red
            '#e67e22', // Orange
            '#f1c40f', // Yellow
            '#2ecc71', // Green
            '#3498db', // Blue
            '#9b59b6'  // Purple
        ];
        let colorIndex = 0;

        // Platform spawn height constraints
        const MIN_PLATFORM_Y = canvas.height - 150;
        const MAX_PLATFORM_Y = canvas.height - 50;

        // Game state
        let score = 0;
        let platforms = [];
        let player = {
            x: 100,
            y: 200,
            velocityY: 0,
            isJumping: false,
            canDoubleJump: false,
            hasDoubleJumped: false
        };
        let lastPlatformY = null;

        // Input handling
        let keys = {};
        let spaceWasPressed = false;

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !keys[e.code]) {
                // Regular jump
                if (!player.isJumping && player.velocityY < 8) {
                    player.velocityY = JUMP_FORCE;
                    player.isJumping = true;
                    player.canDoubleJump = true;
                    player.hasDoubleJumped = false;
                }
                // Double jump
                else if (player.canDoubleJump && !player.hasDoubleJumped && score >= DOUBLE_JUMP_COST) {
                    player.velocityY = DOUBLE_JUMP_FORCE;
                    player.hasDoubleJumped = true;
                    player.canDoubleJump = false;
                    score -= DOUBLE_JUMP_COST;
                    scoreElement.textContent = `Score: ${score}`;
                }
            }
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Platform generation with overlap prevention
        function generatePlatform(x = canvas.width, fixedY = null, width = STANDARD_PLATFORM_WIDTH) {
            let y;
            if (fixedY !== null) {
                y = fixedY;
            } else {
                const minDistance = PLATFORM_HEIGHT * 2;
                do {
                    y = Math.random() * (MAX_PLATFORM_Y - MIN_PLATFORM_Y) + MIN_PLATFORM_Y;
                } while (lastPlatformY !== null && Math.abs(y - lastPlatformY) < minDistance);
            }
            
            lastPlatformY = y;
            
            platforms.push({
                x: x,
                y: y,
                width: width,
                height: PLATFORM_HEIGHT,
                color: PLATFORM_COLORS[colorIndex]
            });

            colorIndex = (colorIndex + 1) % PLATFORM_COLORS.length;
        }

        function initializeGame() {
            platforms = [];
            score = 0;
            colorIndex = 0;
            lastPlatformY = null;
            scoreElement.textContent = `Score: ${score}`;

            const firstPlatformY = canvas.height - 100;
            generatePlatform(50, firstPlatformY, FIRST_PLATFORM_WIDTH);

            player.x = 100;
            player.y = firstPlatformY - PLAYER_SIZE;
            player.velocityY = 0;
            player.isJumping = false;
            player.canDoubleJump = false;
            player.hasDoubleJumped = false;

            for (let i = 1; i < 5; i++) {
                generatePlatform(i * 180 + FIRST_PLATFORM_WIDTH);
            }
        }

        function checkCollision(player, platform) {
            const leniency = 5;
            return player.x + PLAYER_SIZE > platform.x &&
                   player.x < platform.x + platform.width &&
                   player.y + PLAYER_SIZE + leniency > platform.y &&
                   player.y < platform.y + platform.height;
        }

        function update() {
            player.velocityY += GRAVITY;
            player.y += player.velocityY;

            platforms.forEach(platform => {
                const isNearPlatform = 
                    Math.abs((player.y + PLAYER_SIZE) - platform.y) < 10 &&
                    player.x + PLAYER_SIZE > platform.x &&
                    player.x < platform.x + platform.width;
                
                if (isNearPlatform) {
                    player.isJumping = false;
                    player.hasDoubleJumped = false;
                }
            });

            if (player.y < 0) {
                player.y = 0;
                player.velocityY = 0;
            }

            platforms.forEach(platform => {
                platform.x -= GAME_SPEED;

                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0) {
                        player.y = platform.y - PLAYER_SIZE;
                        player.velocityY = 0;
                        player.isJumping = false;
                        player.hasDoubleJumped = false;
                    }
                }
            });

            platforms = platforms.filter(platform => platform.x + platform.width > 0);
            if (platforms.length < 5) {
                generatePlatform();
                score += 10;
                scoreElement.textContent = `Score: ${score}`;
            }

            if (player.y > canvas.height) {
                initializeGame();
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = score >= DOUBLE_JUMP_COST ? '#ffffff' : '#cccccc';  // Dimmer when can't double jump
            ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);

            // Draw platforms with their colors
            platforms.forEach(platform => {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Draw double jump indicator
            if (player.canDoubleJump && score >= DOUBLE_JUMP_COST) {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(player.x + PLAYER_SIZE/2, player.y - 10, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        initializeGame();
        gameLoop();
    </script>
</body>
</html>
