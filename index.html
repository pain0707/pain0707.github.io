<!DOCTYPE html>
<html>
<head>
    <title>THE Greatest Game of all Time</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #gameContainer {
            text-align: center;
        }
        canvas {
            border: 2px solid #fff;
            background-color: #34495e;
        }
        #score {
            color: white;
            font-size: 24px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Score: 0</div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // Game constants
        const STANDARD_PLATFORM_WIDTH = 100;
        const FIRST_PLATFORM_WIDTH = 300;
        const PLATFORM_HEIGHT = 20;
        const PLAYER_SIZE = 20;
        const JUMP_FORCE = -12;
        const DOUBLE_JUMP_FORCE = -10;
        const GRAVITY = 0.7;
        const GAME_SPEED = 5;
        const DOUBLE_JUMP_COST = 50;

        const PLATFORM_COLORS = [
            '#e74c3c', '#e67e22', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6'
        ];
        let colorIndex = 0;

        const MIN_PLATFORM_Y = canvas.height - 150;
        const MAX_PLATFORM_Y = canvas.height - 50;

        let score = 0;
        let platforms = [];
        let player = {
            x: 100,
            y: 200,
            velocityY: 0,
            isJumping: false,
            canDoubleJump: false,
            hasDoubleJumped: false,
            isOnGround: false
        };
        let lastPlatformY = null;
        let lastJumpTime = 0;
        const DOUBLE_TAP_THRESHOLD = 300; // Time window for double tap in milliseconds

        // Input handling
        let keys = {};

        function handleJump() {
            if (player.isOnGround) {
                player.velocityY = JUMP_FORCE;
                player.isJumping = true;
                player.canDoubleJump = true;
                player.hasDoubleJumped = false;
                player.isOnGround = false;
            } else if (player.canDoubleJump && !player.hasDoubleJumped && score >= DOUBLE_JUMP_COST) {
                player.velocityY = DOUBLE_JUMP_FORCE;
                player.hasDoubleJumped = true;
                player.canDoubleJump = false;
                score -= DOUBLE_JUMP_COST;
                scoreElement.textContent = `Score: ${score}`;
            }
        }

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !keys[e.code]) {
                handleJump();
            }
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Touch input
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const currentTime = Date.now();
            const timeSinceLastJump = currentTime - lastJumpTime;
            handleJump();
            lastJumpTime = currentTime;
        }, { passive: false });

        // Prevent default touch behaviors
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
        }, { passive: false });

        function generatePlatform(x = canvas.width, fixedY = null, width = STANDARD_PLATFORM_WIDTH) {
            let y;
            if (fixedY !== null) {
                y = fixedY;
            } else {
                const minDistance = PLATFORM_HEIGHT * 2;
                do {
                    y = Math.random() * (MAX_PLATFORM_Y - MIN_PLATFORM_Y) + MIN_PLATFORM_Y;
                } while (lastPlatformY !== null && Math.abs(y - lastPlatformY) < minDistance);
            }
            
            lastPlatformY = y;
            
            platforms.push({
                x: x,
                y: y,
                width: width,
                height: PLATFORM_HEIGHT,
                color: PLATFORM_COLORS[colorIndex]
            });

            colorIndex = (colorIndex + 1) % PLATFORM_COLORS.length;
        }

        function initializeGame() {
            platforms = [];
            score = 0;
            colorIndex = 0;
            lastPlatformY = null;
            scoreElement.textContent = `Score: ${score}`;

            const firstPlatformY = canvas.height - 100;
            generatePlatform(50, firstPlatformY, FIRST_PLATFORM_WIDTH);

            player.x = 100;
            player.y = firstPlatformY - PLAYER_SIZE;
            player.velocityY = 0;
            player.isJumping = false;
            player.canDoubleJump = false;
            player.hasDoubleJumped = false;
            player.isOnGround = true;

            for (let i = 1; i < 5; i++) {
                generatePlatform(i * 180 + FIRST_PLATFORM_WIDTH);
            }
        }

        function checkCollision(player, platform) {
            const leniency = 5;
            return player.x + PLAYER_SIZE > platform.x &&
                   player.x < platform.x + platform.width + 5 &&
                   player.y + PLAYER_SIZE + leniency > platform.y &&
                   player.y < platform.y + platform.height;
        }

        function update() {
            player.velocityY += GRAVITY;
            player.y += player.velocityY;

            player.isOnGround = false;

            platforms.forEach(platform => {
                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0) {
                        player.y = platform.y - PLAYER_SIZE;
                        player.velocityY = 0;
                        player.isJumping = false;
                        player.hasDoubleJumped = false;
                        player.isOnGround = true;
                    }
                }
            });

            if (player.y < 0) {
                player.y = 0;
                player.velocityY = 0;
            }

            platforms.forEach(platform => {
                platform.x -= GAME_SPEED;
            });

            platforms = platforms.filter(platform => platform.x + platform.width > 0);
            if (platforms.length < 5) {
                generatePlatform();
                score += 10;
                scoreElement.textContent = `Score: ${score}`;
            }

            if (player.y > canvas.height) {
                initializeGame();
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = score >= DOUBLE_JUMP_COST ? '#ffffff' : '#cccccc';
            ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);

            platforms.forEach(platform => {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });

            if (player.canDoubleJump && score >= DOUBLE_JUMP_COST) {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(player.x + PLAYER_SIZE/2, player.y - 10, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        initializeGame();
        gameLoop();
    </script>
</body>
</html>
